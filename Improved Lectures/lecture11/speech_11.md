In the previous lecture, we used decorators to add behavior around functions non-invasively. A decorator wraps a function and injects code before and after the function call. Now we need something similar, but for code blocks rather than function definitions. We need a way to set up a resource before a block of code runs, and guarantee cleanup when the block finishes, whether it finishes normally or raises an exception. That is what context managers do.

Consider a database connection. Without context managers, you open the connection, run your query code, then close the connection. That works perfectly when nothing goes wrong. But what happens when the query code raises an exception? The close call never executes. The connection leaks. In a high-traffic web application handling thousands of requests per minute, leaked connections exhaust the connection pool. New requests cannot connect. The system becomes unresponsive. The engineering team gets paged at two in the morning. The only fix is a restart, which means downtime.

The standard defensive pattern for this problem is try and finally. You write a try block containing your query code, then a finally block containing your cleanup. The finally block always executes, even when an exception occurs. This works. But it is verbose. It is repetitive. If you have five resources to manage, you write five nested try and finally blocks. The actual business logic drowns in cleanup boilerplate. And more importantly, it is a convention, not a guarantee. There is nothing in the language forcing any developer to use it. Under deadline pressure, under time constraints, the try and finally gets skipped. The connection leaks.

Python developers working on file input and output were running into this exact problem. Files would be left open because the close call was missing from exception paths. The bug was common enough, and damaging enough, that Python introduced the with statement in version two point five via a proposal called PEP 343. The goal was to make cleanup impossible to forget by making it part of the syntax itself.

When Python encounters a with statement, it calls the enter method on the context object. That method sets up the resource and returns it. The as clause binds the returned value to a name you choose. Python then runs the indented block of code. When that block finishes, whether it finishes normally, or raises an exception, or even raises a system exit, Python calls the exit method. The cleanup happens. There is no execution path through a with block that bypasses the exit method. The guarantee is absolute and structural.

The entry method on a context manager handles setup. The exit method handles teardown. The exit method receives three arguments that describe any exception that occurred inside the block: the exception type, the exception value, and the traceback. If no exception occurred, all three arguments are None. This gives the exit method complete information about what happened inside the block.

What the exit method returns controls exception handling. If it returns True, the exception is suppressed. Execution continues after the with block as if nothing went wrong. If it returns False, or returns nothing, the exception propagates normally. This means context managers have precise, explicit control over whether exceptions escape the block. A context manager can suppress only specific exception types and let everything else propagate. This separation of cleanup logic from business logic is one of the most powerful aspects of the design.

Consider a data import pipeline processing rows from a large file. Each row is expected to be a number, but some rows are malformed. Without context managers, you would write conditional logic around every row to catch formatting errors, decide whether to skip or abort, and make sure resources are cleaned up regardless of the decision. With a context manager designed for this purpose, the exit method checks whether the exception is a formatting error. If it is, it logs the bad row, suppresses the exception, and the loop continues to the next row. If the exception is something more serious, a network failure or an out of memory error, the exit method returns False, and the exception propagates to halt the import. The business logic of processing each row stays clean. The policy for handling errors lives in the context manager.

Another highly practical use for context managers is instrumentation. Measuring how long a block of code takes to execute is a common need in production systems. The naive approach is to manually record a start time before the block, record an end time after the block, and compute the difference. But that manual bookkeeping can fail the same way the close call fails. If the block raises an exception, the end time never gets recorded. With a timer context manager, the start time is recorded in the entry method. The exit method computes the elapsed time and logs it. The measurement happens regardless of whether the block succeeded or raised an exception. You get accurate timing data from every execution path.

Python provides a shortcut for writing context managers that does not require defining a full class. The contextlib module contains a decorator called contextmanager. When you apply this decorator to a generator function, the generator function becomes a context manager. The code before the yield statement corresponds to the entry method. The yield statement itself produces the value that the as clause receives. The code after the yield statement corresponds to the exit method. A try and finally wrapped around the yield ensures the code after yield runs even when an exception propagates through the yield point.

This generator form is significantly more concise than the class form for straightforward cases. A managed database transaction that opens a connection, yields it to the caller, then commits and closes becomes five lines instead of fifteen. The class form remains the better choice when you need full inspection of exception details or need to implement selective suppression based on exception type. For everything else, the generator form is clean, readable, and preferred.

Context managers compose. You can nest multiple with statements, or on a single line separate them with commas, opening multiple resources at once. All of them are guaranteed to close when the block exits, in reverse order of opening. A file, a database connection, and a lock can all be acquired in one line and released cleanly in one block.

When you see with in production code, you are seeing a guarantee. Django uses context managers to wrap database transactions so that uncommitted changes are always rolled back on failure. The threading module wraps locks in context managers so that a lock is always released, even if the locked code crashes. The tempfile module uses context managers for temporary files that must be deleted when processing is done. This pattern appears everywhere in the Python standard library and every serious Python codebase because it is the correct way to express resource lifecycle.

Context managers make cleanup structural rather than conventional. The entry method sets up. The exit method tears down. That teardown is guaranteed by the language, not by programmer discipline. In the next lecture, we will look at how Python's exception model reflects a complementary philosophy: assume success, and handle failure explicitly, rather than checking every precondition before proceeding.
