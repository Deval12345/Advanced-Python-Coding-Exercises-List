In the previous lecture, we saw how functions can be stored, passed, and returned as values. We built a simple factory, a function that creates another function based on parameters. But something was missing. When that returned function ran, how did it remember the minimum amount. The answer is closures. Closures are the mechanism behind function factories, callbacks, and much of Python's functional style.

Imagine you are building an alert system. You need validators that check whether financial transactions exceed different thresholds. One validator for high-value transactions over ten thousand. Another for standard transactions over one hundred. In a language without closures, you would need to write a class for each validator, or pass the threshold as a parameter every single time. In Python, closures give you a better option. Bake the threshold into the function itself.

A closure is a function that remembers variables from the scope where it was created, even after that outer scope no longer exists. When the outer function finishes and returns the inner function, Python does not discard the local variables of the outer function. Instead, it bundles them up with the inner function as captured state. The inner function carries its creation context wherever it goes.

We define a function named makeThresholdValidator that receives a parameter named thresholdAmount. Inside it, we define another function named checkValue that receives a parameter named transactionValue. The checkValue function returns true if transactionValue is greater than or equal to thresholdAmount. The makeThresholdValidator function returns checkValue. When we call makeThresholdValidator with ten thousand, we get back checkValue, but checkValue still has access to thresholdAmount, which is ten thousand, even though makeThresholdValidator has already returned. That is the closure. The returned function carries the captured thresholdAmount with it.

The variable thresholdAmount is a free variable for checkValue. It is used inside checkValue but defined in the enclosing makeThresholdValidator scope. Python stores free variables in special storage called closure cells, which are attached to the function object. You can inspect them using the closure attribute of any function.

Closures appear everywhere in real systems. Event-driven systems use a callback that captures context from when the event was registered. Retry logic captures the number of retries and the target function. Caching wrappers capture the cached data alongside the wrapped function. Middleware generators produce specialized middleware with baked-in configuration. In a payment processor, a closure can bake the merchant configuration into a fee-calculation function. Instead of passing the config on every call, the function carries it.

We define a function named makePaymentProcessor that receives a parameter named feeRate and a parameter named currency. Inside, we define a function named processPayment that receives a parameter named amount. The processPayment function returns a dictionary with the currency, the original amount, and the computed fee using feeRate. The makePaymentProcessor returns processPayment. We create usdProcessor by calling makePaymentProcessor with a feeRate of zero point zero two and a currency of USD. We create eurProcessor with a feeRate of zero point zero three and EUR. Each processor independently remembers its own configuration.

By default, reading a captured variable works. But what if the closure needs to modify the captured value. For example, counting how many times the function has been called. Without the nonlocal keyword, Python would treat any assignment as creating a new local variable, shadowing the captured one. The nonlocal keyword declares that an assignment inside the inner function should modify the variable in the enclosing scope, not create a new local one.

We define a function named makeCounter. Inside, we define a variable named callCount and set it to zero. We define an inner function named increment. Inside increment, we use the keyword nonlocal with callCount. We add one to callCount and return it. We return the increment function. When we create a counter and call increment multiple times, callCount persists between calls. The closure modifies the captured variable each time. This creates a function with built-in stateful behavior, without needing a class.

Lambda is a way to create a small, anonymous function inline. It creates the same kind of function object as def, but it is limited to a single expression and has no name attached. Lambda is most useful when you need a function briefly for a single operation. Sorting by a key field. Filtering with a condition. Mapping a simple transformation. In these cases, defining a full named function with def would be verbose.

We have a list named transactionList where each item is a dictionary with keys amount and currency. We use sorted with a key argument set to a lambda that extracts the amount key from each transaction. The lambda takes a single parameter named record and returns record at the amount key. This sorts the list by amount without defining a separate named function.

Lambda should stay small and readable. If the function needs more than one expression, use def. If the lambda is complex enough to need a comment, use def. If you are assigning the lambda to a variable and never using it as an inline argument, use def. The goal is readability. Lambda is a convenience tool, not a replacement for proper function definitions.

A closure with captured state is structurally equivalent to a class with one method. The closure captures variables the way a class stores instance attributes. For simple, single-method behavior, closures are more concise. For complex state with multiple behaviors, classes are clearer. If you need one callable behavior with private state, use a closure. If you need multiple methods or want to expose the state clearly, use a class.

Closures allow functions to carry their creation context with them. They enable configuration baking, stateful callbacks, and a lightweight alternative to single-method classes. The nonlocal keyword allows closures to modify captured state. Lambda provides inline anonymous functions for simple transformations. Together, these tools make Python's function system remarkably expressive. In the next lecture, we move to iterators and generators, where functions that produce sequences transform how Python processes data.
