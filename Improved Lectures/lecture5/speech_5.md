Over the last four lectures we have been building objects that respond to Python syntax through special methods and protocols. We defined custom containers, implemented operator overloading, and used duck typing to write flexible, behavior-driven systems. But now a fundamental question arises: how does Python actually store and share these objects in memory? This lecture answers that question, and the answer affects every line of code you will ever write.

The most important insight of this lecture is this: in Python, a variable is not a box that contains a value. A variable is a label attached to an object. When you come from C or Java, you are used to thinking of a variable as a memory slot that holds a value directly. Python is completely different. When Python executes an assignment like productList equals a list containing laptop, phone, and tablet, Python first creates a list object somewhere in memory, and then attaches the name productList to that object. The name is not the object. The name is a label pointing to the object.

The consequence of this design is aliasing. If you write catalogAlias equals productList, Python does not create a new list. It creates a second label and attaches it to the exact same object. You now have two names pointing to one list. When you call append on catalogAlias and add monitor to the list, productList shows all four items too, because both names point to the same object. The modification happened to the object, not to any particular name.

This matters enormously in industry. In a web application built on Django or Flask, a developer might store a user's configuration in a dictionary and pass it to multiple functions for rendering, validation, and logging. If any of those functions modifies the dictionary, every other function sees the change. The bug appears as behavior that depends on call order, or state that leaks between requests, or a permission level that was supposed to be read-only but was accidentally changed. The root cause is always the same: the developer did not realise they were passing a reference, not a copy.

Python gives us two different operators for comparing variables, and they answer two completely different questions. The equality operator calls the special dunder method eq on the left-hand object, asking: are these two objects equal in value? The is operator asks a different question: are these two names attached to the exact same object in memory? It does not call any method. It compares memory addresses directly. So two lists with identical content are value-equal but not identity-equal, because they were created separately and live at different memory addresses. An alias of the first list is identity-equal to it, because both names point to the same object.

There is a rule that every professional Python programmer follows: never write double-equals None. Always write is None. The reason is that the equality operator calls dunder method eq, and a custom class can override that method to return True under any condition, including when compared to None. If you write objectInstance double-equals None, and the class author made dunder method eq return True for everything, your None check silently fails. The is operator does not call any method. It is a direct memory-address comparison. None is a singleton in Python, meaning there is exactly one None object in the entire runtime. So is None reliably checks whether you have the actual None object. No custom class can interfere with that.

Not all objects behave the same way when you have multiple names pointing to them. Mutable objects, such as lists, dictionaries, sets, and most custom objects, can have their internal state changed in-place. Immutable objects, such as integers, strings, tuples, and frozensets, cannot be changed once created. When Python appears to modify an immutable object, it actually creates a new object and leaves the original untouched. This distinction is critical when you have aliases. If you define a list of exam scores, assign a second name to it as a so-called backup, and then append a new score through the first name, the backup reference shows the new value too, because both names point to the same mutable list object. The name backup is misleading and dangerous. This is exactly the kind of bug that hides in production code, where a developer assumes a second variable is an independent copy, but it is only an alias.

Python's copy module gives you precise control over how to duplicate objects, and there are three levels to understand. The first level is simple assignment, which does not copy anything at all. It creates a new name pointing to the same object. The second level is shallow copy, created using copy dot copy. This creates a new outer container, but the elements inside the container are not copied. They are the same objects, now referenced from two places. The third level is deep copy, created using copy dot deepcopy. This recursively copies every object in the entire structure, producing a completely independent copy with no shared references.

The difference becomes visible with nested data structures. Consider an application configuration dictionary that contains another dictionary for settings, with keys for timeout and retries. If you shallow-copy the outer dictionary and then modify the nested timeout value through the copy, the original also shows the change, because the shallow copy shared the inner dictionary object. But if you deep-copy the outer dictionary, the nested dictionary is also duplicated, so modifying the copy has no effect on the original. The practical rule is: use shallow copy when the outer container needs independence but the inner objects are immutable or intentionally shared. Use deep copy when you need complete independence, such as for configuration templates, test fixtures, or snapshots of state that must remain stable.

Python evaluates the truthiness of any object in a boolean context by checking first for dunder method bool, then for dunder method len, and finally defaulting to True. The built-in falsy values are None, zero, empty strings, empty lists, empty dictionaries, and empty sets. This enables the clean Pythonic pattern of writing if not queue instead of the verbose if the length of queue equals zero. You can define dunder method len on a custom TaskQueue class, and then writing if not processingQueue will call dunder method len, see that the task list is empty, and evaluate correctly to falsy. When you add a task and check again, the length is positive and the queue evaluates as truthy.

There is a subtler problem with default arguments. Sometimes you need to distinguish between no argument being provided and None being explicitly provided as an argument. If you use None as your default value, you cannot tell the difference. The solution is the sentinel pattern. You create a unique object using object parentheses and assign it to a module-level name like MISSING. Because object parentheses creates a new object with a unique identity every time, your sentinel is guaranteed to be unlike any other value. You use it as your default argument and check for it using is. This lets you handle three distinct cases in a single function: no argument provided, None explicitly provided, and an actual value provided.

Python's reference semantics are a deliberate design choice that makes passing large data structures efficient and enables flexible shared state management. But they place responsibility on you. You must know when two names point to the same object. You must know when to copy and at what depth. You must use is for identity checks, and is None for None checks, and dunder methods for truthiness. These concepts appear in every data pipeline where DataFrames are passed between processing steps, in every web application where configuration is shared between request handlers, and in every test suite where fixtures must be properly isolated. Now that you understand how Python stores and shares objects in memory, you are ready to explore how Python treats functions as first-class objects, values that can be passed, stored, and returned just like any other data.
