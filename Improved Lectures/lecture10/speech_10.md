In the previous two lectures, we saw that functions can be stored in variables, passed as arguments, and returned from other functions. We saw that closures capture context from their enclosing scope and keep that context alive as long as something holds a reference to the inner function. Now we put both of those ideas together. A decorator is a function that takes another function as input and returns a modified version of it. That is the whole thing. The at-sign syntax is just a shorthand for something you already know how to do.

To understand why decorators exist, think about what happens in large production systems. Every API endpoint needs to check whether the user is authenticated. Every database call needs retry logic in case the connection drops. Every expensive computation needs to be timed so engineers can catch performance regressions. Every public method needs a log entry for auditing. Without decorators, you copy and paste the same authentication check into every view function. You copy the same try-except retry block into every database call. When the retry logic changes — and it will — you update it in three hundred places and hope you did not miss any. That is the problem decorators were designed to solve.

Decorators make cross-cutting concerns into composable layers. Your payment function handles payments. A retry decorator handles retrying. A logging decorator handles logging. Each layer is independent, testable, and reusable across the entire codebase from a single implementation.

A decorator follows three steps. First, it receives a function as its argument. Second, it defines a new wrapper function that calls the original function, adding behavior before or after or both. Third, it returns that wrapper function. When you write the at-sign followed by a decorator name above a function definition, Python executes the equivalent of rebinding the function's name to the result of calling the decorator with that function. The name that used to point to your original function now points to the wrapper. The original function still exists, captured inside the wrapper's closure.

Here is what this looks like in practice. You define a function called logCall that receives a parameter called targetFunction. Inside logCall, you define a function called wrapper that accepts star-args and double-star-kwargs so it can transparently forward any arguments. The wrapper prints a message using targetFunction's name, then calls targetFunction with those forwarded arguments and returns whatever targetFunction returns. Then logCall returns wrapper. When you place the at-sign and logCall above a function called processPayment, every call to processPayment now prints a log message automatically. The processPayment function itself never changes. The logging concern lives entirely inside logCall.

The at-sign syntax is syntactic sugar. Python sees the at-sign and the decorator name above a def statement and applies the decorator automatically at module load time. The function is transformed once, before any calling code runs. You can also stack multiple decorators by writing one at-sign per line above the function definition. They are applied from bottom to top. The decorator closest to the function is applied first, and each one above it wraps the result of the one below.

Now there is a subtle problem with naive wrapping. When you replace a function with a wrapper, the wrapper's name and docstring replace the original function's metadata. Every decorated function appears to be named wrapper. Debugging becomes confusing, stack traces show the wrong names, and any tool that inspects function metadata gets incorrect information. The solution is functools.wraps. You apply it as a decorator to your wrapper function, passing the original function as the argument. It copies the original function's name, docstring, module, and annotations onto the wrapper. From that point on, the wrapper looks like the original to every inspection tool. You should always use functools.wraps in any decorator you intend to use in production.

Consider a timing decorator. You define a function called measureTime that receives targetFunction. Inside, you apply functools.wraps to the wrapper using targetFunction. The wrapper records a start time, calls targetFunction with all forwarded arguments, records an end time, computes the elapsed duration, prints it with targetFunction's name, and returns the result. Now you can apply measureTime to any function and get precise timing output without modifying that function at all. The name attribute of the decorated function still shows the original name, not wrapper.

Sometimes a decorator itself needs configuration. A retry decorator needs to know how many attempts to allow. A rate limiter needs a maximum calls per second. This requires one additional level of wrapping. You write an outer function that accepts the configuration and returns a decorator. The decorator accepts the function and returns a wrapper. The wrapper does the actual work. When you use the at-sign syntax with parentheses — providing the configuration — Python calls the outer function first, gets a decorator back, and applies that decorator to the function below. You define retryOnFailure with a parameter called maxAttempts. Inside, you define a decorator that receives targetFunction. Inside that, you define a wrapper that loops up to maxAttempts times, tries calling targetFunction, returns the result immediately on success, and after all attempts are exhausted raises the last exception. retryOnFailure returns decorator. Now a single well-tested implementation handles retry logic for every function in the system.

Three structural patterns cover nearly every decorator use case in practice. The pre-condition pattern runs setup logic before calling the function: checking authentication, validating inputs, establishing a connection. The post-condition pattern runs cleanup logic after the function returns: logging the result, committing a transaction, releasing a resource. The around pattern wraps the entire call: timing it, returning a cached result early if one exists, or calling the function again if it fails. All three use the same wrapper structure. The only difference is where the call to targetFunction appears relative to the surrounding logic.

These patterns appear throughout the Python ecosystem. Django's login-required decorator adds an authentication check without touching view logic. Flask's app.route decorator registers a function as a URL handler at module load time. Python's built-in property decorator turns a method into an attribute. The Tenacity library's retry decorator adds exponential backoff to any function. Prometheus and StatsD use timer decorators for performance monitoring across entire services.

Decorators transform function behavior without modifying function code. The at-sign syntax makes the transformation visible at the point of definition, so the intent is clear to every reader. functools.wraps preserves function identity so all tooling works correctly. Configurable decorators add one more wrapping level to accept parameters. In the next lecture, we will explore context managers, which apply the same kind of structural thinking to the problem of guaranteed resource cleanup.
