In the previous lecture, we studied Python's exception model and the EAFP philosophy — assume success and handle failure explicitly. We used special methods like __enter__ and __exit__ to give classes structural power over how code blocks behave. Now we go one level deeper into Python's object model. Descriptors control what happens when you access an attribute on an object. They are the engine behind property, classmethod, staticmethod, and every major ORM framework you have used. Everything you have ever touched through dot notation on a Python class — that behavior is defined by the descriptor protocol.

Let us start with a problem that exists in every real production codebase. Classes have constraints. An employee's salary must be positive. A server configuration's port number must fall between 1 and 65535. A machine learning model's probability output must be between 0 and 1. A hardware sensor reading must stay within the sensor's operational range. These are not optional rules — they are invariants. If they are violated, you get corrupted data, silent incorrect behavior, or bugs that are nearly impossible to trace back to their origin.

The naive solution is to validate in __init__ and in every setter. If a class has three validated fields, you write three range checks in __init__. If another class needs the same range check, you copy the code. After five classes, you have five independent copies of the same logic. When the business rule changes — the port range now excludes certain reserved ports — you must update all five. If you miss one, the inconsistency goes unnoticed. This duplication problem scales badly. Descriptors solve it by making the validation rule a self-contained, reusable object that can be attached to any class attribute.

So what exactly is a descriptor? A descriptor is any object that defines __get__, __set__, or __delete__. When you assign a descriptor instance to a class attribute, Python rewires how that attribute works. Instead of going to the instance dictionary directly, Python calls the descriptor's methods. __get__ is called when you read the attribute. __set__ is called when you assign to it. __delete__ is called when you delete it.

There is an important distinction between data descriptors and non-data descriptors. A data descriptor defines both __get__ and __set__, or defines __get__ and __delete__. A non-data descriptor defines only __get__. This distinction controls lookup priority. A data descriptor takes priority over the instance's own __dict__. Even if the instance has an entry in its dictionary under the same key, the data descriptor wins. A non-data descriptor, on the other hand, loses to the instance __dict__. We will use this priority difference in the next lecture to build lazy caching. For now, understand that all validators you write will be data descriptors.

Let us look at the first example. We define a class called RangeValidated. The constructor stores a minimum value and a maximum value. It also initializes attributeName to None. The __set_name__ method — which Python calls automatically in version 3.6 and later — receives the owner class and the name of the attribute this descriptor is assigned to. We store that name. In __get__, we first check whether instance is None. This check handles the case where someone accesses the attribute through the class rather than through an instance — we return self in that case. Otherwise, we retrieve the value from the instance's own __dict__. In __set__, we check the range. If the value falls outside, we raise ValueError with a message that includes the attribute name, the allowed bounds, and the actual bad value. If the value is valid, we store it in instance.__dict__. We then define SensorReading with temperature using RangeValidated from negative fifty to one hundred fifty, and humidity using RangeValidated from zero to one hundred. Both attributes are validated by the same class. Creating a reading with valid values works. An invalid temperature would immediately raise ValueError.

Now let us talk about __set_name__ specifically, because it solves a real historical bug. Before Python 3.6 introduced it, you had to pass the attribute name to the descriptor's constructor explicitly. You would write salary = PositiveNumber('salary'). The name appeared twice — once in the assignment on the left, and once as a string argument on the right. If you renamed the attribute, you had to remember to update the string. When you forgot, the error messages named the wrong attribute, or worse, two attributes silently shared the same storage key. __set_name__ is called automatically at class creation time, so the descriptor always knows exactly which attribute it is attached to, without any manual repetition.

This brings us to the comparison between descriptors and Python's built-in property. Property is itself a descriptor. But property is one-per-attribute. You write a getter, a setter, and a deleter for each attribute, and you cannot reuse that property definition across different classes. A descriptor class, by contrast, is instantiated once per attribute across any number of classes. Our second example shows exactly this. We define PositiveNumber as a single descriptor class with type checking and positivity validation. We attach it to both Product — which has price and quantity — and Invoice — which has totalAmount and taxRate. Four validated attributes. One descriptor class. No duplicated logic. When the validation requirement changes, we change one class. This is the pattern behind SQLAlchemy columns, Django model fields, Python's dataclasses, and the attrs library.

Before we move on, let us examine that instance-is-None check more carefully. Every well-written descriptor's __get__ begins with it. Python calls __get__ in two situations. When you access the attribute on an instance, instance is the object. When you access the attribute through the class itself — SensorReading.temperature rather than reading.temperature — instance is None. If you do not check for None and return early, the code crashes because it tries to look something up in instance.__dict__ when instance is None. Returning self when instance is None means class-level access returns the descriptor object itself. This is not just defensive coding — it is how Django's query system works. MyModel.field_name returns the field descriptor. The query builder calls methods on that descriptor object to construct SQL. The entire ORM API depends on this check.

Descriptors are not something external you add to Python. They are how Python itself is implemented. Property is a descriptor. Classmethod is a descriptor — its __get__ returns a bound method where the first argument is the class rather than the instance, which is why you can call MyClass.some_classmethod() without an instance. Staticmethod is a descriptor — its __get__ returns the raw function unchanged, which is why static methods receive neither self nor cls. When you understand descriptors, you understand why Python's own built-in features work the way they do.

The key takeaways from this lecture are these. A descriptor is any object with __get__, __set__, or __delete__. Data descriptors — those with __set__ — take priority over instance __dict__. __set_name__ is called automatically when the descriptor is assigned to a class attribute, letting the descriptor know its own name. The primary use case is reusable attribute validation: one descriptor class, attached to attributes in many classes, validation logic in one place. In the next lecture, we will look at non-data descriptors and the patterns they enable: lazy loading, computed properties, and how framework authors use descriptors to build class-level APIs that behave differently depending on whether you access them through the class or through an instance.
